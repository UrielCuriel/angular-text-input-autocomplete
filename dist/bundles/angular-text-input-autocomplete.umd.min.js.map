{"version":3,"sources":["ng://angular-text-input-autocomplete/text-input-autocomplete-menu.component.ts","ng://angular-text-input-autocomplete/text-input-autocomplete.directive.ts","ng://angular-text-input-autocomplete/text-input-autocomplete-container.component.ts","ng://angular-text-input-autocomplete/text-input-autocomplete.module.ts"],"sourcesContent":["import {\n  Component,\n  ElementRef,\n  HostListener,\n  ViewChild,\n  HostBinding\n} from '@angular/core';\nimport { Subject } from 'rxjs';\n\n@Component({\n  selector: 'mwl-text-input-autocomplete-menu',\n  template: `\n    <div\n      *ngIf=\"choices?.length > 0\"\n      #dropdownMenu\n      class=\"dropdown-menu\">\n        <a  *ngFor=\"let choice of choices; trackBy:trackById\"\n        [class.active]=\"activeChoice === choice\"\n          (click)=\"selectChoice.next(choice)\" class=\"dropdown-item\">\n          {{ choice }}\n        </a>\n    </div>\n  `,\n  styles: [\n    `\n      :host {\n        z-index: 100000;\n        position: fixed;\n      }\n      .dropdown-menu {\n        display: block;\n        max-height: 200px;\n        overflow-y: auto;\n      }\n    `\n  ]\n})\nexport class TextInputAutocompleteMenuComponent {\n  @ViewChild('dropdownMenu') dropdownMenuElement: ElementRef<HTMLUListElement>;\n  position: { top: number; left: number };\n  selectChoice = new Subject();\n  activeChoice: any;\n  searchText: string;\n  choiceLoadError: any;\n  choiceLoading = false;\n  private _choices: any[];\n  trackById = (index: number, choice: any) =>\n    typeof choice.id !== 'undefined' ? choice.id : choice;\n\n  set choices(choices: any[]) {\n    this._choices = choices;\n    if (choices.indexOf(this.activeChoice) === -1 && choices.length > 0) {\n      this.activeChoice = choices[0];\n    }\n  }\n\n  get choices() {\n    return this._choices;\n  }\n  @HostBinding('style.top.px')\n  get top() {\n    const screenHeight = window.screen.height;\n    const menuHeight = this.dropdownMenuElement\n      ? this.dropdownMenuElement.nativeElement.offsetHeight\n      : 0;\n\n    return this.position.top + menuHeight < screenHeight\n      ? this.position.top\n      : this.position.top - menuHeight;\n  }\n  @HostBinding('style.left.px')\n  get left() {\n    const screenWidth = window.screen.width;\n    const menuWidth = this.dropdownMenuElement\n      ? this.dropdownMenuElement.nativeElement.offsetWidth\n      : 0;\n    return this.position.left + menuWidth < screenWidth\n      ? this.position.left\n      : this.position.left - menuWidth;\n  }\n\n  @HostListener('document:keydown.ArrowDown', ['$event'])\n  onArrowDown(event: KeyboardEvent) {\n    event.preventDefault();\n    const index = this.choices.indexOf(this.activeChoice);\n    if (this.choices[index + 1]) {\n      this.scrollToChoice(index + 1);\n    }\n  }\n\n  @HostListener('document:keydown.ArrowUp', ['$event'])\n  onArrowUp(event: KeyboardEvent) {\n    event.preventDefault();\n    const index = this.choices.indexOf(this.activeChoice);\n    if (this.choices[index - 1]) {\n      this.scrollToChoice(index - 1);\n    }\n  }\n\n  @HostListener('document:keydown.Enter', ['$event'])\n  onEnter(event: KeyboardEvent) {\n    if (this.choices.indexOf(this.activeChoice) > -1) {\n      event.preventDefault();\n      this.selectChoice.next(this.activeChoice);\n    }\n  }\n\n  private scrollToChoice(index: number) {\n    this.activeChoice = this._choices[index];\n    if (this.dropdownMenuElement) {\n      const ulPosition = this.dropdownMenuElement.nativeElement.getBoundingClientRect();\n      const li = this.dropdownMenuElement.nativeElement.children[index];\n      const liPosition = li.getBoundingClientRect();\n      if (liPosition.top < ulPosition.top) {\n        li.scrollIntoView();\n      } else if (liPosition.bottom > ulPosition.bottom) {\n        li.scrollIntoView(false);\n      }\n    }\n  }\n}\n","import {\n  ComponentFactoryResolver,\n  ComponentRef,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostListener,\n  Injector,\n  Input,\n  OnDestroy,\n  Output,\n  ViewContainerRef,\n  ApplicationRef,\n  EmbeddedViewRef\n} from '@angular/core';\nimport getCaretCoordinates from 'textarea-caret';\nimport { takeUntil } from 'rxjs/operators';\nimport { TextInputAutocompleteMenuComponent } from './text-input-autocomplete-menu.component';\nimport { Subject } from 'rxjs';\n\nexport interface ChoiceSelectedEvent {\n  choice: any;\n  insertedAt: {\n    start: number;\n    end: number;\n  };\n}\n\n@Directive({\n  selector:\n    'textarea[mwlTextInputAutocomplete],input[type=\"text\"][mwlTextInputAutocomplete]'\n})\nexport class TextInputAutocompleteDirective implements OnDestroy {\n  /**\n   * The character that will trigger the menu to appear\n   */\n  @Input() triggerCharacter: string = '@';\n\n  /**\n   * The regular expression that will match the search text after the trigger character\n   */\n  @Input() searchRegexp = /^\\w*$/;\n\n  /**\n   * The menu component to show with available options.\n   * You can extend the built in `TextInputAutocompleteMenuComponent` component to use a custom template\n   */\n  @Input() menuComponent = TextInputAutocompleteMenuComponent;\n\n  /**\n   * Called when the options menu is shown\n   */\n  @Output() menuShown = new EventEmitter();\n\n  /**\n   * Called when the options menu is hidden\n   */\n  @Output() menuHidden = new EventEmitter();\n\n  /**\n   * Called when a choice is selected\n   */\n  @Output() choiceSelected = new EventEmitter<ChoiceSelectedEvent>();\n\n  /**\n   * A function that accepts a search string and returns an array of choices. Can also return a promise.\n   */\n  @Input() findChoices: (searchText: string) => any[] | Promise<any[]>;\n\n  /**\n   * A function that formats the selected choice once selected.\n   */\n  @Input() getChoiceLabel: (choice: any) => string = choice => choice;\n\n  /**\n   * Whether to close the menu when the host textarea loses focus\n   */\n  @Input() closeMenuOnBlur = false;\n\n  /* tslint:disable member-ordering */\n  private menu:\n    | {\n        component: ComponentRef<TextInputAutocompleteMenuComponent>;\n        triggerCharacterPosition: number;\n        lastCaretPosition?: number;\n      }\n    | undefined;\n\n  private menuHidden$ = new Subject();\n  menuElem: HTMLElement;\n\n  constructor(\n    private componentFactoryResolver: ComponentFactoryResolver,\n    private viewContainerRef: ViewContainerRef,\n    private appRef: ApplicationRef,\n    private injector: Injector,\n    private elm: ElementRef\n  ) {}\n\n  @HostListener('keypress', ['$event.key'])\n  onKeypress(key: string) {\n    if (\n      (this.triggerCharacter !== '**' && key === this.triggerCharacter) ||\n      (this.triggerCharacter === '**' && /[a-z|A-Z]/.test(key))\n    ) {\n      this.showMenu();\n    }\n  }\n\n  @HostListener('input', ['$event.target.value'])\n  onChange(value: string) {\n    if (this.menu) {\n      if (\n        !value ||\n        (value[this.menu.triggerCharacterPosition] !== this.triggerCharacter &&\n          this.triggerCharacter !== '**')\n      ) {\n        this.hideMenu();\n      } else {\n        const cursor = this.elm.nativeElement.selectionStart;\n        if (cursor < this.menu.triggerCharacterPosition) {\n          this.hideMenu();\n        } else {\n          const searchText = value.slice(\n            this.menu.triggerCharacterPosition +\n              (this.triggerCharacter === '**' ? 0 : 1),\n            cursor\n          );\n          if (!searchText.match(this.searchRegexp)) {\n            this.hideMenu();\n          } else {\n            this.menu.component.instance.searchText = searchText;\n            this.menu.component.instance.choices = [];\n            this.menu.component.instance.choiceLoadError = undefined;\n            this.menu.component.instance.choiceLoading = true;\n            this.menu.component.changeDetectorRef.detectChanges();\n            Promise.resolve(this.findChoices(searchText))\n              .then(choices => {\n                if (this.menu) {\n                  this.menu.component.instance.choices = choices;\n                  this.menu.component.instance.choiceLoading = false;\n                  this.menu.component.changeDetectorRef.detectChanges();\n                }\n              })\n              .catch(err => {\n                if (this.menu) {\n                  this.menu.component.instance.choiceLoading = false;\n                  this.menu.component.instance.choiceLoadError = err;\n                  this.menu.component.changeDetectorRef.detectChanges();\n                }\n              });\n          }\n        }\n      }\n    }\n  }\n\n  @HostListener('blur')\n  onBlur() {\n    if (this.menu) {\n      this.menu.lastCaretPosition = this.elm.nativeElement.selectionStart;\n      if (this.closeMenuOnBlur === true) {\n        this.hideMenu();\n      }\n    }\n  }\n\n  private showMenu() {\n    if (!this.menu) {\n      const menuFactory = this.componentFactoryResolver.resolveComponentFactory<\n        TextInputAutocompleteMenuComponent\n      >(this.menuComponent);\n      this.menu = {\n        component: this.viewContainerRef.createComponent(\n          menuFactory,\n          0,\n          this.injector\n        ),\n        triggerCharacterPosition: this.elm.nativeElement.selectionStart\n      };\n      //Get DOM element from component\n      this.menuElem = (this.menu.component.hostView as EmbeddedViewRef<any>)\n        .rootNodes[0] as HTMLElement;\n\n      // Append Menu element to the body\n      document.body.appendChild(this.menuElem);\n\n      const lineHeight = +getComputedStyle(\n        this.elm.nativeElement\n      ).lineHeight!.replace(/px$/, '');\n\n      const elmPositionTop = this.elm.nativeElement.getBoundingClientRect().top;\n      const elmPositionLeft = this.elm.nativeElement.getBoundingClientRect()\n        .left;\n      const { top, left } = getCaretCoordinates(\n        this.elm.nativeElement,\n        this.elm.nativeElement.selectionStart\n      );\n      this.menu.component.instance.position = {\n        top: elmPositionTop + top + lineHeight,\n        left: elmPositionLeft + left\n      };\n\n      this.menu.component.changeDetectorRef.detectChanges();\n      this.menu.component.instance.selectChoice\n        .pipe(takeUntil(this.menuHidden$))\n        .subscribe(choice => {\n          const label = this.getChoiceLabel(choice);\n          const textarea: HTMLTextAreaElement = this.elm.nativeElement;\n          const value: string = textarea.value;\n          const startIndex = this.menu!.triggerCharacterPosition;\n          const start = value.slice(0, startIndex);\n          const caretPosition =\n            this.menu!.lastCaretPosition || textarea.selectionStart;\n          const end = value.slice(caretPosition);\n          textarea.value = start + label + end;\n          // force ng model / form control to update\n          textarea.dispatchEvent(new Event('input'));\n          this.hideMenu();\n          const setCursorAt = (start + label).length;\n          textarea.setSelectionRange(setCursorAt, setCursorAt);\n          textarea.focus();\n          this.choiceSelected.emit({\n            choice,\n            insertedAt: {\n              start: startIndex,\n              end: startIndex + label.length\n            }\n          });\n        });\n      this.menuShown.emit();\n    }\n  }\n\n  private hideMenu() {\n    if (this.menu) {\n      this.menu.component.destroy();\n      this.menuHidden$.next();\n      this.menuHidden.emit();\n      this.menu = undefined;\n    }\n  }\n\n  ngOnDestroy() {\n    this.hideMenu();\n  }\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'mwl-text-input-autocomplete-container',\n  styles: [\n    `\n    :host {\n      position: relative;\n      display: block;\n    }\n  `\n  ],\n  template: '<ng-content></ng-content>'\n})\nexport class TextInputAutocompleteContainerComponent {}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { TextInputAutocompleteDirective } from './text-input-autocomplete.directive';\nimport { TextInputAutocompleteContainerComponent } from './text-input-autocomplete-container.component';\nimport { TextInputAutocompleteMenuComponent } from './text-input-autocomplete-menu.component';\n\n@NgModule({\n  declarations: [\n    TextInputAutocompleteDirective,\n    TextInputAutocompleteContainerComponent,\n    TextInputAutocompleteMenuComponent\n  ],\n  imports: [CommonModule],\n  exports: [\n    TextInputAutocompleteDirective,\n    TextInputAutocompleteContainerComponent,\n    TextInputAutocompleteMenuComponent\n  ],\n  entryComponents: [TextInputAutocompleteMenuComponent]\n})\nexport class TextInputAutocompleteModule {}\n"],"names":["TextInputAutocompleteMenuComponent","Object","defineProperty","prototype","this","_choices","choices","indexOf","activeChoice","length","screenHeight","window","screen","height","menuHeight","dropdownMenuElement","nativeElement","offsetHeight","position","top","screenWidth","width","menuWidth","offsetWidth","left","onArrowDown","event","preventDefault","index","scrollToChoice","onArrowUp","onEnter","selectChoice","next","ulPosition","li","getBoundingClientRect","liPosition","children","scrollIntoView","bottom","Component","args","selector","template","styles","ViewChild","HostBinding","HostListener","Subject","choice","id","TextInputAutocompleteDirective","onKeypress","key","triggerCharacter","test","showMenu","onChange","value","cursor","searchText","_this","menu","triggerCharacterPosition","elm","selectionStart","slice","match","searchRegexp","component","instance","choiceLoadError","undefined","choiceLoading","changeDetectorRef","detectChanges","Promise","resolve","findChoices","then","catch","err","hideMenu","onBlur","lastCaretPosition","closeMenuOnBlur","lineHeight","elmPositionTop","elmPositionLeft","top_1","menuFactory","componentFactoryResolver","resolveComponentFactory","menuComponent","viewContainerRef","createComponent","injector","menuElem","rootNodes","document","body","appendChild","getComputedStyle","replace","_a","getCaretCoordinates","pipe","takeUntil","menuHidden$","subscribe","label","getChoiceLabel","textarea","startIndex","start","caretPosition","end","dispatchEvent","Event","setCursorAt","setSelectionRange","focus","choiceSelected","emit","insertedAt","menuShown","destroy","menuHidden","ngOnDestroy","Directive","ComponentFactoryResolver","ViewContainerRef","ApplicationRef","Injector","ElementRef","Input","Output","appRef","EventEmitter","TextInputAutocompleteContainerComponent","NgModule","declarations","imports","CommonModule","exports","entryComponents","TextInputAutocompleteModule"],"mappings":"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"}